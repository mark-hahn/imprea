// Generated by CoffeeScript 1.9.3

/*
  imprea.coffee
  Imperative reactive framework (DSL) for node and the browser.
 */

(function() {
  var Imperea, _, globalObservableValues, globalObservers, nameList,
    slice = [].slice;

  _ = require('lodash');

  globalObservers = {};

  globalObservableValues = {};

  nameList = function() {
    var arg, args, func, i, j, len, len1, name, names;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    func = null;
    names = [];
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      switch (false) {
        case !_.isFunction(arg):
          func = arg;
          break;
        case !_.isArray(arg):
          names = names.concat(nameList(arg).names);
          break;
        case !_.isObject(arg):
          names = names.concat(_.keys(arg));
          break;
        default:
          names.push(arg.toString());
      }
    }
    for (j = 0, len1 = names.length; j < len1; j++) {
      name = names[j];
      if (name === 'outputs' || name === 'description' || name === 'react' || name === 'prototype' || name === '__proto__' || name === 'constructor' || name === 'toString') {
        throw new Error({
          message: ("Imprea Error in " + this.nameSpace + ": \"" + name + "\" is reserved ") + 'and may not be used as the name of an output observable.'
        });
      }
    }
    return {
      func: func,
      names: names
    };
  };

  module.exports = Imperea = (function() {
    function Imperea() {}

    constructor(function(nameSpace) {
      this.nameSpace = nameSpace;
    });

    Imperea.prototype.outputs = function() {
      var args, i, len, name, nl, ref, results;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      nl = nameList(args);
      ref = nl.names;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        results.push(this[name] = (function(_this) {
          return function(value) {
            var j, len1, observer, ref1, ref2, results1;
            if (!_.isEqual(globalObservableValues[name], value)) {
              globalObservableValues[name] = value;
              ref2 = (ref1 = globalObservers[name]) != null ? ref1 : [];
              results1 = [];
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                observer = ref2[j];
                observer.imprea[name] = value;
                results1.push(observer.func.call(observer.imprea, name, value));
              }
              return results1;
            }
          };
        })(this));
      }
      return results;
    };

    Imperea.prototype.description = function(description) {
      this.description = description;
    };

    Imperea.prototype.react = function() {
      var args, func, i, len, name, nl, ref, results;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args[0] === '*') {
        args = _.keys(globalObservableValues);
      }
      nl = nameList(args);
      if (!(func = nl.func)) {
        throw new Error({
          message: ("Imprea Error in " + this.nameSpace + ": ") + 'a react argument list must contain a function.'
        });
      }
      ref = nl.names;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        if (this[name] == null) {
          this[name] = null;
        }
        if (globalObservers[name] == null) {
          globalObservers[name] = [];
        }
        results.push(globalObservers[name].push({
          imprea: this,
          func: func
        }));
      }
      return results;
    };

    return Imperea;

  })();

}).call(this);
